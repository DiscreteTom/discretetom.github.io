(window.webpackJsonp=window.webpackJsonp||[]).push([[106,671],{1247:function(v,_,l){const n={render:function(){this.$createElement;return this._self._c,this._m(0)},staticRenderFns:[function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("div",{staticClass:"frontmatter-markdown"},[n("h2",{attrs:{id:"一些概念"}},[v._v("一些概念")]),v._v(" "),n("ul",[n("li",[v._v("指令集体系ISA(Instruction Set Architecture)：\n"),n("ul",[n("li",[v._v("寄存器组织\n"),n("ul",[n("li",[v._v("寄存器个数")]),v._v(" "),n("li",[v._v("寄存器尺寸")])])]),v._v(" "),n("li",[v._v("处理器组织\n"),n("ul",[n("li",[v._v("地址空间")]),v._v(" "),n("li",[v._v("寻址粒度")])])]),v._v(" "),n("li",[v._v("指令集\n"),n("ul",[n("li",[v._v("操作码表")]),v._v(" "),n("li",[v._v("寻址方式")]),v._v(" "),n("li",[v._v("指令格式")])])])])]),v._v(" "),n("li",[v._v("复杂指令集计算机体系CISC: Complex Instruction Set Computer\n"),n("ul",[n("li",[v._v("通用寄存器数量少")]),v._v(" "),n("li",[v._v("寻址方式多")]),v._v(" "),n("li",[v._v("专用、复杂指令种类多")]),v._v(" "),n("li",[v._v("指令比较长")])])]),v._v(" "),n("li",[v._v("精简指令集计算机体系RISC: Reduced Instruction Set Computer\n"),n("ul",[n("li",[v._v("指令集被简化")]),v._v(" "),n("li",[v._v("固定长度、固定格式的指令字")]),v._v(" "),n("li",[v._v("流水线操作")]),v._v(" "),n("li",[v._v("寻址方式少")]),v._v(" "),n("li",[v._v("可用寄存器数量多")])])]),v._v(" "),n("li",[v._v("CISC vs RISC\n"),n("ul",[n("li",[v._v("CISC\n"),n("ul",[n("li",[v._v("比RISC执行的指令条数少（代码密度高")]),v._v(" "),n("li",[v._v("取指操作少，降低功耗")])])]),v._v(" "),n("li",[v._v("RISC\n"),n("ul",[n("li",[v._v("执行的指令多")]),v._v(" "),n("li",[v._v("功耗大")]),v._v(" "),n("li",[v._v("每条指令功耗低")]),v._v(" "),n("li",[v._v("易于流水线")])])])])])]),v._v(" "),n("p",[v._v("指令的构成：")]),v._v(" "),n("ul",[n("li",[v._v("操作码 - 说明计算机要执行哪种操作")]),v._v(" "),n("li",[v._v("操作数 - 操作涉及的对象（可能0个也可能多个")])]),v._v(" "),n("h2",{attrs:{id:"寻址方式"}},[v._v("寻址方式")]),v._v(" "),n("h3",{attrs:{id:"分类"}},[v._v("分类")]),v._v(" "),n("ol",[n("li",[v._v("立即寻址")]),v._v(" "),n("li",[v._v("寄存器寻址")]),v._v(" "),n("li",[v._v("直接寻址")]),v._v(" "),n("li",[v._v("寄存器间接寻址")]),v._v(" "),n("li",[v._v("寄存器相对寻址")]),v._v(" "),n("li",[v._v("基址变址寻址")]),v._v(" "),n("li",[v._v("相对基址变址寻址")]),v._v(" "),n("li",[v._v("…")])]),v._v(" "),n("p",[v._v("上面的除了立即寻址和寄存器寻址，其他的都属于"),n("strong",[v._v("存储器寻址")]),v._v("（即去存储器寻找数据")]),v._v(" "),n("h3",{attrs:{id:"存储器寻址"}},[v._v("存储器寻址")]),v._v(" "),n("p",[v._v("需要考虑三个因素：")]),v._v(" "),n("ul",[n("li",[v._v("有效地址EA: Effective Address\n"),n("ul",[n("li",[v._v("操作数地址（物理地址）=段基址+偏移地址（有效地址）")]),v._v(" "),n("li",[v._v("EA=基址+变址*比例因子+位移量\n"),n("ul",[n("li",[v._v("基址不是段基址，存放在基址寄存器而不是段寄存器")]),v._v(" "),n("li",[v._v("变址存放在段寄存器")]),v._v(" "),n("li",[v._v("比例因子和位移量由指令给出，也可能仅仅是CS:IP+1。指令会给出寻址方式")])])])])]),v._v(" "),n("li",[v._v("默认段\n"),n("ul",[n("li",[v._v("指令 - CS")]),v._v(" "),n("li",[v._v("堆栈 - SS")]),v._v(" "),n("li",[v._v("局部数据 - DS")]),v._v(" "),n("li",[v._v("串处理的目的串 - ES")])])]),v._v(" "),n("li",[v._v("段超越\n"),n("ul",[n("li",[v._v("如果不想使用如上默认段，可以使用段超越来访问非默认段")]),v._v(" "),n("li",[v._v("格式为"),n("code",{pre:!0},[v._v("段寄存器:操作数")]),v._v("，如"),n("code",{pre:!0},[v._v("ds:[1000h]")])])])])]),v._v(" "),n("h3",{attrs:{id:"寻址举例"}},[v._v("寻址举例")]),v._v(" "),n("ul",[n("li",[v._v("立即寻址\n"),n("ul",[n("li",[v._v("操作数在指令中")]),v._v(" "),n("li",[v._v("mov ax, 0000h")])])]),v._v(" "),n("li",[v._v("寄存器寻址\n"),n("ul",[n("li",[v._v("操作数在寄存器中")]),v._v(" "),n("li",[v._v("mov ax, bx")])])]),v._v(" "),n("li",[v._v("直接寻址\n"),n("ul",[n("li",[v._v("EA在指令中")]),v._v(" "),n("li",[v._v("mov ax, [1000h]")])])]),v._v(" "),n("li",[v._v("寄存器间接寻址\n"),n("ul",[n("li",[v._v("EA在"),n("strong",[v._v("BX/BP/SI/DI")]),v._v("中（只有这四个寄存器可以作为偏移量")]),v._v(" "),n("li",[v._v("mov ax, [bx]")]),v._v(" "),n("li",[v._v("如果使用bp作为基址，默认段寄存器为SS")])])]),v._v(" "),n("li",[v._v("寄存器相对寻址\n"),n("ul",[n("li",[v._v("EA为bx/bp/si/di加上某个常数")]),v._v(" "),n("li",[v._v("mov ax, [bx+10]")]),v._v(" "),n("li",[v._v("mov ax, bx[10]")]),v._v(" "),n("li",[v._v("mov ax, 10[bx]")]),v._v(" "),n("li",[v._v("使用bp的时候默认段寄存器为SS")])])]),v._v(" "),n("li",[v._v("基址变址寻址\n"),n("ul",[n("li",[v._v("EA为基址寄存器和变址寄存器内容之和")]),v._v(" "),n("li",[v._v("mov ax, [bx+si]")]),v._v(" "),n("li",[v._v("mov ax, bx[si]")]),v._v(" "),n("li",[v._v("mov ax, si[bx]")]),v._v(" "),n("li",[v._v("基址寄存器为bp时默认段寄存器为SS")])])]),v._v(" "),n("li",[v._v("相对基址变址寻址\n"),n("ul",[n("li",[v._v("EA为基址寄存器和变址寄存器和某个常数之和")]),v._v(" "),n("li",[v._v("mov ax, [bx+si+10]")]),v._v(" "),n("li",[v._v("mov ax, 10[bx][si]")])])])]),v._v(" "),n("p",[v._v("其他在80386中才有")]),v._v(" "),n("h2",{attrs:{id:"转移指令"}},[v._v("转移指令")]),v._v(" "),n("p",[v._v("根据上一章内容我们知道物理地址为20位。所以指令的物理地址为"),n("code",{pre:!0},[v._v("CS*16+IP")])]),v._v(" "),n("p",[v._v("顺序执行时IP自动增加，CS内容不变")]),v._v(" "),n("p",[v._v("转移的分类：")]),v._v(" "),n("ul",[n("li",[v._v("段内转移 - 只修改IP")]),v._v(" "),n("li",[v._v("段间转移 - 修改IP和CS")])]),v._v(" "),n("p",[v._v("但是编写汇编程序的时候，使用label和转移指令，汇编程序会帮助我们计算转移")]),v._v(" "),n("h2",{attrs:{id:"8086指令"}},[v._v("8086指令")]),v._v(" "),n("h3",{attrs:{id:"数据传送指令"}},[v._v("数据传送指令")]),v._v(" "),n("ul",[n("li",[v._v("通用数据传送指令\n"),n("ul",[n("li",[v._v("mov dst, src\n"),n("ul",[n("li",[v._v("不影响标志位")]),v._v(" "),n("li",[v._v("可以是8位指令，也可以是16位指令")]),v._v(" "),n("li",[v._v("寻址方式：\n"),n("ul",[n("li",[v._v("mov reg, reg/mem/imm")]),v._v(" "),n("li",[v._v("mov mem, reg/imm")])])])])]),v._v(" "),n("li",[v._v("push src\n"),n("ul",[n("li",[v._v("不影响标志位")]),v._v(" "),n("li",[v._v("寻址方式：\n"),n("ul",[n("li",[v._v("push mem/reg")])])]),v._v(" "),n("li",[v._v("先移动栈顶指针再copy值入栈顶")]),v._v(" "),n("li",[v._v("栈顶指针SP向上移动（地址变小")]),v._v(" "),n("li",[v._v("16位指令，指针每次减2")]),v._v(" "),n("li",[v._v("SP为0的时候堆栈溢出（即堆栈偏移量为0，到达SS")])])]),v._v(" "),n("li",[v._v("pop dst\n"),n("ul",[n("li",[v._v("不影响标志位")]),v._v(" "),n("li",[v._v("寻址方式：\n"),n("ul",[n("li",[v._v("pop mem/reg")])])]),v._v(" "),n("li",[v._v("先弹出数据再移动栈顶指针")]),v._v(" "),n("li",[v._v("栈顶指针SP向下移动（地址变大")]),v._v(" "),n("li",[v._v("16位指令，指针每次加2")])])]),v._v(" "),n("li",[v._v("xchg opr1, opr2\n"),n("ul",[n("li",[v._v("不影响标志位")]),v._v(" "),n("li",[v._v("寻址方式：\n"),n("ul",[n("li",[v._v("xchg mem/reg, mem/reg")])])])])])])]),v._v(" "),n("li",[v._v("累加器专用传送指令\n"),n("ul",[n("li",[v._v("in & out\n"),n("ul",[n("li",[v._v("指令格式：\n"),n("ul",[n("li",[v._v("in al/ax, 端口地址")]),v._v(" "),n("li",[v._v("out 端口地址, al/ax")]),v._v(" "),n("li",[v._v("端口地址必须是立即数或dx中的数")])])]),v._v(" "),n("li",[v._v("不影响标志位")])])]),v._v(" "),n("li",[v._v("xlat（略")])])]),v._v(" "),n("li",[v._v("地址传送指令\n"),n("ul",[n("li",[v._v("LEA reg, src\n"),n("ul",[n("li",[v._v("把src的EA送到reg")])])])])]),v._v(" "),n("li",[v._v("标志寄存器传送指令\n"),n("ul",[n("li",[v._v("lahf - 把FR内容放到AH")]),v._v(" "),n("li",[v._v("sahf - 把AH内容放到FR")]),v._v(" "),n("li",[v._v("pushd - push FR")]),v._v(" "),n("li",[v._v("popf - pop FR")])])]),v._v(" "),n("li",[v._v("类型转换指令\n"),n("ul",[n("li",[v._v("不影响标志寄存器")]),v._v(" "),n("li",[v._v("cbw - 字节变字")]),v._v(" "),n("li",[v._v("cwd - 字变双字")]),v._v(" "),n("li",[v._v("cdq - 双字变四字")])])])]),v._v(" "),n("h3",{attrs:{id:"算术运算指令"}},[v._v("算术运算指令")]),v._v(" "),n("ul",[n("li",[v._v("加法\n"),n("ul",[n("li",[v._v("add - 加法")]),v._v(" "),n("li",[v._v("adc - 带进位加法（加CF")]),v._v(" "),n("li",[v._v("inc - 加1")])])]),v._v(" "),n("li",[v._v("减法\n"),n("ul",[n("li",[v._v("sub - 减法")]),v._v(" "),n("li",[v._v("sbb - 带借位减法（减CF")]),v._v(" "),n("li",[v._v("cmp - 比较（不保留结果，只保留FR")]),v._v(" "),n("li",[v._v("dec - 减1")]),v._v(" "),n("li",[v._v("neg - 求补（按位取反后+1")])])]),v._v(" "),n("li",[v._v("乘法\n"),n("ul",[n("li",[v._v("mul src\n"),n("ul",[n("li",[v._v("[ax] <- [al] * [src]")]),v._v(" "),n("li",[v._v("[dx:ax] <- [ax] * [src]")]),v._v(" "),n("li",[v._v("因为操作数仅为src，所以src要用来判断是8位乘法还是16位乘法，所以src必须为寄存器或存储器")]),v._v(" "),n("li",[v._v("乘法结束后位数要拓展一倍，即8位乘法得到16位结果，16位乘法得到32位结果")])])])])]),v._v(" "),n("li",[v._v("除法\n"),n("ul",[n("li",[v._v("div src\n"),n("ul",[n("li",[v._v("[al] <- [ax] / [src]的商")]),v._v(" "),n("li",[v._v("[ah] <- [ax] / [src]的余数")]),v._v(" "),n("li",[v._v("[ax] <- [dx:ax] / [src]的商")]),v._v(" "),n("li",[v._v("[dx] <- [dx:ax] / [src]的余数")]),v._v(" "),n("li",[v._v("和乘法一样，需要靠src判断是8位还是16位除法，所以src必须为寄存器或存储器")])])])])]),v._v(" "),n("li",[v._v("十进制调整（略")])]),v._v(" "),n("h3",{attrs:{id:"逻辑运算指令"}},[v._v("逻辑运算指令")]),v._v(" "),n("ul",[n("li",[v._v("and - 逻辑与")]),v._v(" "),n("li",[v._v("or - 逻辑或")]),v._v(" "),n("li",[v._v("xor - 逻辑异或")]),v._v(" "),n("li",[v._v("test - 逻辑与，不保存结果")]),v._v(" "),n("li",[v._v("not - 按位取反")]),v._v(" "),n("li",[v._v("sal - 算数左移，符号位不左移。移出去的结果放在CF")]),v._v(" "),n("li",[v._v("sar - 算数右移，同上")]),v._v(" "),n("li",[v._v("shl - 逻辑左移，移出去的结果放在CF")]),v._v(" "),n("li",[v._v("shr - 逻辑右移，同上")]),v._v(" "),n("li",[v._v("rol - 循环左移，移出去的放到末尾和CF")]),v._v(" "),n("li",[v._v("ror - 循环右移，同上")]),v._v(" "),n("li",[v._v("rcl - 带进位循环左移，把CF放到末尾，然后把移出去的放到CF")]),v._v(" "),n("li",[v._v("rcr - 带进位循环右移，同上")])]),v._v(" "),n("p",[n("strong",[v._v("移位指令的位数如果不是1，需要放到cl中指明")])]),v._v(" "),n("h3",{attrs:{id:"串处理指令"}},[v._v("串处理指令")]),v._v(" "),n("p",[v._v("数据串string保存在内存中，存放连续的字节或字序列。使用DS:SI指定源串，ES:DI指定目的串，使用CX指定串操作长度，DF指定串操作方向（即SI和DI是递增还是递减")]),v._v(" "),n("p",[n("img",{attrs:{src:l(813),alt:"3-1"}})]),v._v(" "),n("ul",[n("li",[v._v("串操作指令\n"),n("ul",[n("li",[v._v("movs\n"),n("ul",[n("li",[v._v("movsb - 移动一个字节")]),v._v(" "),n("li",[v._v("movsw - 移动一个字")]),v._v(" "),n("li",[v._v("movsd - 移动一个双字")])])]),v._v(" "),n("li",[v._v("stos\n"),n("ul",[n("li",[v._v("stosb")]),v._v(" "),n("li",[v._v("stosw")]),v._v(" "),n("li",[v._v("stosd")])])]),v._v(" "),n("li",[v._v("lods同上，有三种")]),v._v(" "),n("li",[v._v("cmps同上，有三种，比较结果保存在FR")]),v._v(" "),n("li",[v._v("scas同上，有三种，比较源串和[al]或[ax]或[dx:ax]，结果保存在FR。用于搜索")]),v._v(" "),n("li",[v._v("ins - 串输入，有三种，把端口号在DX的IO空间的数据输入到DI指向的内存")]),v._v(" "),n("li",[v._v("outs - 串输出，把si指向的数据段中的数据输出到DX保存的IO端口")])])]),v._v(" "),n("li",[v._v("重复前缀\n"),n("ul",[n("li",[v._v("rep - 无条件重复\n"),n("ul",[n("li",[v._v("rep movsb")])])]),v._v(" "),n("li",[v._v("repe(repz) - 为0重复")]),v._v(" "),n("li",[v._v("repne(repne) - 非0重复")])])])]),v._v(" "),n("h3",{attrs:{id:"控制转移指令"}},[v._v("控制转移指令")]),v._v(" "),n("ul",[n("li",[v._v("无条件转移指令\n"),n("ul",[n("li",[v._v("jmp")])])]),v._v(" "),n("li",[v._v("条件转移指令\n"),n("ul",[n("li",[v._v("jc")]),v._v(" "),n("li",[v._v("je")]),v._v(" "),n("li",[v._v("ja")]),v._v(" "),n("li",[v._v("jb")]),v._v(" "),n("li",[v._v("…")])])]),v._v(" "),n("li",[v._v("循环指令\n"),n("ul",[n("li",[v._v("loop\n"),n("ul",[n("li",[v._v("内部使用cx进行计数")])])])])]),v._v(" "),n("li",[v._v("子程序调用指令\n"),n("ul",[n("li",[v._v("call & ret")])])]),v._v(" "),n("li",[v._v("中断指令\n"),n("ul",[n("li",[v._v("int")]),v._v(" "),n("li",[v._v("into - 溢出中断")]),v._v(" "),n("li",[v._v("iret - 中断返回")])])])]),v._v(" "),n("h3",{attrs:{id:"处理机控制指令"}},[v._v("处理机控制指令")]),v._v(" "),n("ul",[n("li",[v._v("标志处理指令\n"),n("ul",[n("li",[v._v("clc - 清进位，即CF置0")]),v._v(" "),n("li",[v._v("cmc - 进位标志CF取反")]),v._v(" "),n("li",[v._v("stc - 置进位CF为1")]),v._v(" "),n("li",[v._v("cld - 清方向DF为0")]),v._v(" "),n("li",[v._v("std - 设置DF为1")]),v._v(" "),n("li",[v._v("cli - 清中断IF为0")]),v._v(" "),n("li",[v._v("sti - 置中断IF为1")])])]),v._v(" "),n("li",[v._v("其他处理机控制指令\n"),n("ul",[n("li",[v._v("nop - 无操作，用于预占存储单元或软件延时")]),v._v(" "),n("li",[v._v("hlt - 停机指令，等待中断，中断返回后继续执行下一条指令")]),v._v(" "),n("li",[v._v("…")])])])])])}]};v.exports={attributes:{layout:"collection",title:"指令系统与寻址方式",collection:"MicrocomputerPrincipleAndInterfaceTechnology"},vue:{render:n.render,staticRenderFns:n.staticRenderFns,component:{data:function(){return{templateRender:null}},render:function(v){return this.templateRender?this.templateRender():v("div","Rendering")},created:function(){this.templateRender=n.render,this.$options.staticRenderFns=n.staticRenderFns}}}}},813:function(v,_,l){v.exports=l.p+"img/e368025.png"}}]);
---
title: 理解TCP协议中SEQ与ACK的计算逻辑
tags:
  - 计算机网络
---

## 三次握手

tcpdump 抓包示例（删除了不必要的字段）：

```
172.31.27.207.33944 > 192.168.242.180.27017: Flags [S], seq 1310410798 ... length 0
192.168.242.180.27017 > 172.31.27.207.33944: Flags [S.], seq 3727471852, ack 1310410799 ... length 0
172.31.27.207.33944 > 192.168.242.180.27017: Flags [.], ack 3727471853 ... length 0
```

- 第一次握手：客户端发送 SYN 包，seq 为 1310410798
  - 客户端：我要从 1310410799（注意此处+1） 开始发送数据
- 第二次握手：服务端发送 SYN+ACK 包，首先通过 ack = seq + 1 确认收到了客户端的 SYN 包，然后发送自己的 SYN 包，seq 为 3727471852
  - 服务器：OK，我会从 1310410799（注意此处+1）开始接收数据，同时我也要从 3727471853（注意此处+1）开始发送数据
- 第三次握手：客户端发送 ACK 包，通过 ack = seq + 1 确认收到了服务端的 SYN+ACK 包
  - 客户端：OK，我会从 3727471853（注意此处+1）开始接收数据

## 数据传输

### 案例 1

tcpdump 抓包示例（删除了不必要的字段）：

```
172.31.27.207.33944 > 192.168.242.180.27017: Flags [P.], seq 1310410799:1310411195, ack 3727471853 ... length 396
192.168.242.180.27017 > 172.31.27.207.33944: Flags [.], ack 1310411195 ... length 0
192.168.242.180.27017 > 172.31.27.207.33944: Flags [P.], seq 3727471853:3727475566, ack 1310411195 ... length 3713
172.31.27.207.33944 > 192.168.242.180.27017: Flags [.], ack 3727475566 ... length 0
172.31.27.207.33944 > 192.168.242.180.27017: Flags [P.], seq 1310411195:1310411333, ack 3727475566 ... length 138
192.168.242.180.27017 > 172.31.27.207.33944: Flags [P.], seq 3727475566:3727475840, ack 1310411333 ... length 274
```

- 第一个包：根据三次握手协商的客户端 seq，客户端发送 1310410799-1310411195 的数据（不包括 1310411195，共 396 字节），并基于三次握手中服务器的 seq 发送 ack = seq + 1
- 第二个包：服务器收到客户端的数据，发送 ack = seq + 1（因为客户端的 seq 不包括 1310411195，所以服务器返回的 ack = seq + 1，是 1310411195）
- 第三个包：根据三次握手协商的服务端 seq，服务器发送 3727471853-3727475566 的数据（不包括 3727475566，共 3713 字节），并再次发送 ack = 1310411195，因为客户端 seq 没有变化
- 第四个包：客户端收到服务端的数据，发送 ack = seq + 1
- 后面的略

以上是典型的【客户端 SEQ -> 服务器 ACK -> 服务器 SEQ -> 客户端 ACK】的流程，相当于客户端和服务器每次只说一句话，交替说

### 案例 2

```
192.168.242.180.27017 > 172.31.27.207.33954: Flags [P.], seq 3168350326:3168353222, ack 664805962 ... length 2896
172.31.27.207.33954 > 192.168.242.180.27017: Flags [.], ack 3168353222 ... length 0
192.168.242.180.27017 > 172.31.27.207.33954: Flags [P.], seq 3168353222:3168354039, ack 664805962 ... length 817
172.31.27.207.33954 > 192.168.242.180.27017: Flags [.], ack 3168354039 ... length 0
```

在此案例里面，服务器连着说了两句话，客户端只负责 ACK，没有发送数据，所以出现了第一个包和第三个包的 ack 相同的情况（因为客户端没有发数据，所以客户端 seq 不变，所以服务端的 ack 也不变）

### 案例 3

```
172.31.27.207.33944 > 192.168.242.180.27017: Flags [P.], seq 1310411195:1310411333, ack 3727475566 ... length 138
192.168.242.180.27017 > 172.31.27.207.33944: Flags [P.], seq 3727475566:3727475840, ack 1310411333 ... length 274
172.31.27.207.33944 > 192.168.242.180.27017: Flags [P.], seq 1310411333:1310411708, ack 3727475840 ... length 375
192.168.242.180.27017 > 172.31.27.207.33944: Flags [P.], seq 3727475840:3727476944, ack 1310411708 ... length 1104
172.31.27.207.33944 > 192.168.242.180.27017: Flags [.], ack 3727476944 ... length 0
```

在此案例中，服务器和客户端进行密集地通信，每个包都既包含数据又包含 ack

- 第一个包：客户端发送 1310411195-1310411333 的数据（不包括 1310411333，共 138 字节），并发送 ack = 3727475566
- 第二个包：服务器发送 3727475566-3727475840 的数据（不包括 3727475840，共 274 字节），并发送 ack = 1310411333，确认第一个包已收到

## 四次挥手

```
172.31.27.207.33944 > 192.168.242.180.27017: Flags [F.], seq 1310411708, ack 3727476944 ... length 0
192.168.242.180.27017 > 172.31.27.207.33944: Flags [F.], seq 3727476944, ack 1310411709 ... length 0
172.31.27.207.33944 > 192.168.242.180.27017: Flags [.], ack 3727476945 ... length 0
```

虽说是四次握手，但是第 2/3 次握手是同时进行的，所以看起来像是三次握手

## 总结

- 客户端和服务器各维护自己的 seq
- 客户端和服务器各维护对方的 ack
- 握手/挥手时，ack = seq + 1
- 传输数据时，ack = seq + data length
- 如何保证可靠传输？验证 seq/ack 满足以上规则即可，如果不合法，则丢弃
- 如果双方同时发包？会导致 ack/seq 不满足以上规则，从而丢包，避免冲突的出现

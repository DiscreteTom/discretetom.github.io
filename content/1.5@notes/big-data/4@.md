---
title: Big Data(Part 4)
description: Zookeeper
tags:
  - Hadoop
---

## 前言

本文是观看[此视频](https://www.bilibili.com/video/BV1Y4411B7jy)时的笔记

## Zookeeper

### 概述

- 开源、分布式，基于Java
  - leader/follower模式(master/slave)
  - 只要有**半数以上**节点存活，就可以正常工作
  - 全局数据一致。每个节点保存一份相同的数据
    - 因为仅存储配置信息，所以数据量很小
- 是一个【分布式服务】管理框架
- 基于观察者模式（详见设计模式）
  - 存储和管理一些数据
  - 接受观察者的注册
  - 一旦数据状态发生变化，就通知观察者
- 来自客户端的请求被顺序执行
- 数据更新有原子性，要么成功要么失败
- 场景
  - 统一命名服务
    - 管理DNS
    - 服务之间使用域名相互通信，由Zookeeper解析IP地址
  - 统一配置管理
    - 管理节点上面服务的配置文件
    - 所有节点监听Zookeeper上面的配置文件信息
  - 统一集群管理
    - 监听节点状态，同步到其他节点
  - 节点动态上下线
  - 软负载均衡
    - 在Zookeeper中记录每台机器的访问量。使访问量最少的机器处理新的客户端请求

### 数据结构

- 类似于文件系统，是树形结构
- 每个节点称为一个`ZNode`
  - 每个ZNode都有一个唯一的路径
  - 每个ZNode默认可以保存1MB的数据

### 原理

#### 选举机制

- 半数机制：集群中半数以上机器存活，则集群可用
  - 所以Zookeeper适合安装在奇数台机器上
- 通过内部选举机制，临时产生leader，而不是手动指定

选举过程：

0. 假设集群中有5台机器
1. 机器A启动，在集群广播消息，无响应，所以把自己编号设置为1，并投票给编号最大的机器（A）。目前A有1票，所以不是leader
2. 机器B启动，在集群广播消息，A响应，所以把自己的编号设置为2。A和B都投票给编号最大的机器（B）。目前B有2票，不是leader
3. 机器C启动，在集群广播消息，AB响应，所以把自己的编号设置为3。ABC都投票给编号最大的机器（C）。目前C有3票，成为leader
4. 机器DE启动，在集群广播消息，得到响应，设置自己的编号。由于C已经是leader，所以不再竞选leader

#### 节点类型

- 持久(persistent)
  - 客户端和服务器断开连接后，创建的节点不删除
- 持久且编号(persistent sequential)
  - 客户端和服务器断开连接后，创建的节点不删除，且在节点名称中添加一个递增编号
  - 编号由父节点维护，实现递增
  - 编号可以用来对事件进行排序
  - 带编号的节点可以同名。因为它们的id中带有唯一的编号
- 短暂(ephemeral)
  - 客户端和服务器断开连接后（会话结束时），创建的节点自己删除
- 短暂且编号。略

#### Stat结构体

- 每个节点都有一个stat结构体。有点类似于linux文件系统的stat
- 内容
  - `cZxid`创建节点的事务的id
    - 每次修改ZK状态都会收到一个zxid形式的时间戳，也就是zookeeper事务ID
    - 每次修改都有唯一的zxid
    - 如果zxid-1小于zxid-2，那么zxid-1在zxid-2之前发生
  - `ctime`节点被创建的时间（从1970年开始，毫秒）
  - `mZxid`最后一次修改节点的事务的id
  - `mtime`最后一次修改节点的时间
  - `pZxid`最后更新的子节点的事务的id
  - `cVersion`子节点修改次数
  - `dataVersion`节点数据修改次数
  - `aclVersion`访问控制列表修改次数
  - `ephemeralOwner`临时节点的拥有者的会话ID。如果不是临时节点就是0
  - `dataLength`节点数据长度
  - `numChildren`子节点数量

### 监听器原理

1. 客户端创建两个线程：负责主动网络通信的线程`connect`和负责监听的线程`listener`
2. 客户端通过connect线程把【注册监听】事件发送给ZK服务器。服务器记录`<client>:<ip>:<port>:<path>`
3. 出现事件时，ZK服务器主动向listener线程汇报事件
4. 客户端调用`process`方法处理事件

### 写数据流程

1. 客户端向ZK服务器1写数据
2. 如果服务器1不是leader，就把消息发送给leader
3. leader把消息广播给各个server
4. 每个server写成功后会通知leader
5. 如果大多数server写成功了，就说明数据写成功了。写成功之后，leader会通知服务器1写成功了
6. 服务器1通知客户端写成功

### 命令

- `bin/zkServer.sh start|status|stop`启动本地模式服务端
- `bin/zkCli.sh`启动命令行工具
  - `ls`查看数据树
    - `watch`监听
  - `ls2`查看详细数据。在新版本中推荐使用`ls -s`
  - `create`创建普通持久节点
    - `-s`带有编号的节点
    - `-e`临时节点（重启或者超时消失）
  - `get/set`读取/写入节点的值
  - `stat`查看节点状态
    - `watch`监听
  - `delete`删除节点
  - `rmr`递归删除
  - `help`查看命令
  - `quit`退出

### 主要配置项

```conf
# 心跳（毫秒）
tickTime=2000
# 初次同步最多花费几次心跳。如果超时，则认为此follower离线
initLimit=10
# 集群正常状态每次同步最多花费几次心跳
syncLimit=5
# 数据目录
dataDir=/opt/module/zookeeper-x.x.x/zkData
# 客户端连接服务器时连接的端口（服务端端口）
clientPort=2181
```

### 配置集群

1. 安装软件
2. 配置机器编号：在数据目录（即配置文件里面的`dataDir`）下创建一个`myid`文件，里面写上编号(id)
   1. 每个机器的编号都不同，通常是从1开始的数字
3. 修改配置文件`zoo.cfg`。添加`server.<id>=<hostname>:<port-1>:<port-2>`
   1. `port-1`是此机器和集群leader交换数据副本的端口.比如2888
   2. `port-2`是此机器用来进行选举的端口。比如3888
4. 启动各机器上面的ZK服务器


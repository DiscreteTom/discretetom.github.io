---
title: 单体架构，掌控时序
description: 控制事件的发生顺序
---

## 前言

此架构思路来自[此视频](https://www.bilibili.com/video/BV1JB4y1S7hk)

以下内容以使用 Unity3D 引擎为例

## 思路

- 代码尽量都使用命名空间进行区分
- 全局只有一个顶层的 GameObject: APP
  - 只有 APP 可以执行 Start/Update 等生命周期函数
  - 其他所有对象都仅提供 public 方法或委托，以供 APP 调用，而自身并不进行生命周期管理与更新
    - 其他对象可以提供类似的生命周期方法，或者初始化函数/构造函数，但是由 APP 统一调度，而不是被 Unity3D 引擎调度
- 围绕着 APP 进行模块化
  - 因为 APP 是唯一入口，所以我们可以像实现非游戏软件一样，实现游戏客户端
    - 比如分层，只能高层访问底层，不能底层访问高层
      - APP 是最高层，可以访问所有底层
      - 也可以基于 namespace 进行可见性控制
  - 当 APP 比较大的时候，就可以考虑模块化，把逻辑抽离出去，并且不是 MonoBehavior
  - 可能不再需要单例，因为由 APP 统一进行资源管理，可以创建一个 Repository 类，管理各种对象资源
    - 尽量不使用单例，因为使用单例的时候可能没有考虑单例的创建和删除等生命周期，并且各处都可以访问到单例，没有良好的分层与访问控制。当然，如果确定需要使用单例，还是可以用的
- 其他 GameObject 仅进行表现层的更新，而内部状态由 APP 进行维护
- 尽量避免拖拽绑定
  - 因为如果 Meta 文件不小心丢失，拖拽绑定就会失效
  - 可以使用 Assets 进行指定
    - 创建一个 AssetsManager，保存一个字典，可以直接根据资源名来获取资源
    - 建议使用插件：Addressables / AssetBundle
    - 或者使用原生的 Resources
- UI 组件中不要写业务逻辑。UI 组件仅用来触发业务逻辑
- 使用静态类，缓存需要缓存的对象，而不是通过类的字段。这样可以显著减少类的字段数量，并且可以被外界访问到
- 使用消息/EventBus 进行跨模块通信
- 把程序分为几个阶段然后清晰地按顺序调用
  - 比如：创建阶段（类似 Awake），连接其他模块的阶段（类似 Start），每帧执行的阶段（类似 Update），销毁的阶段等
- 业务逻辑建议使用 Command/EventBus 进行处理，而不是直接在实体类里面处理
  - 实体类发出 Command/Event，由业务逻辑 Controller 进行处理
  - 实体类之间相互不可知，但是可以通过接口进行实体类型的判断
  - 而高层的 Controller 是可以知道具体的实体类的

## 源码示例

https://www.bilibili.com/read/cv17517838

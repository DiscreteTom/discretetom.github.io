---
title: 智能合约
description:
---

## 前言

本文是观看[此视频](https://www.bilibili.com/video/BV1NJ411D7rf)时整理的笔记

## 前置知识

- 智能合约部署时，由普通账户给一个特殊的全 0 地址（Contract Creator）发出交易，即可部署。部署后会得到一个合约的地址
- 部署后的合约无法修改。重新部署会得到新的地址

## 数据存储

- Storage
  - 每个账户都有的 256 位到 256 位的 k/v 存储
  - 永久保存在区块链中，读写消耗的 gas 最多
- Memory
  - 每一次消息调用，合约都会获得一块内存
  - 合约执行完毕后，内存被释放
  - 仅用来保存临时变量，gas 开销比较小
- Stack
  - EVM 不是基于寄存器的，是基于栈的，所有的计算都在栈里面进行
  - 存放部分局部变量，几乎免费使用，但是数量有限制

## EVM 指令集

- 所有指令都是针对 256 位的字进行操作
- 具备算数、位、逻辑、比较、跳转等操作
- 合约可以访问当前区块的属性，比如块高度和时间戳

## 创建与销毁合约

- 普通用户可以给`0x0`发交易从而创建合约
- 合约可以使用`create calls`创建其他合约
- 唯一从区块链移除合约的方式就是执行`selfdestruct`操作进行自毁
  - 合约上面剩余的以太币会发送给指定的目标
  - 存储的代码和状态会被移除

## Solidity

### 概述

- Solidity 是一个面向合约的语言
- 静态类型，支持继承、库、自定义类型
- 在 EVM 上运行
- `.sol`作为扩展名
- 包含一些独有的数据类型，比如`address`
- 一旦出现异常，所有执行都会回退
- Solidity 编写的智能合约源码会被编译为字节码(Bytecode)，编译会同时产生智能合约的二进制接口规范(ABI: Application Binary Interface)
  - 字节码被部署到以太坊网络
  - 使用 JavaScript 编写的 DAPP 通常通过 web3+ABI 调用智能合约中的函数
- 主流的编译器
  - Remix，基于 web 的 IDE：https://remix.ethereum.org
  - solcjs，基于命令行和 npm: `npm install -g solc`

### 语法

- `pragma`指定语言版本
- `import`导入其他源文件

### 数据类型

- 值类型
  - bool
  - int8/uint8 ... int256/uint256 - 整型
    - 默认 `int/uint` 都是 256 位的
  - fixed/ufixed - 浮点型（有符号、无符号）
    - 比如`fixed128x28`表示一共 128 位，其中 28 位是小数
    - 默认`fixed/ufixed`是`128x19`
  - address
    - 20 字节的地址
    - `address payable`，v0.5.0 引入的新类型，多了`transfer`和`send`两个成员
    - `address(0)`获取`0x0`的地址
    - `address(this)`获取当前合约的地址
    - 成员变量
      - balance - 余额，单位为 wei
      - transfer - 从合约给地址发以太，失败时抛出异常。固定消耗 2300 gas
      - send - 从合约给地址发以太，失败时返回 false。固定消耗 2300 gas
      - call - 调用其他函数。发送者为此合约。默认发送所有剩余 gas。底层函数，不常用
      - delegatecall - 代理调用其他函数。发送者为此合约的发送者。默认发送所有剩余 gas。底层函数，不常用
      - staticcall - 调用其他方法时不会改变状态。默认发送所有剩余 gas。底层函数，不常用
  - enum
  - function
  - bytes1, ... bytes32
- 引用类型
  - array
    - 可以动态调整大小
    - 如果是 storage 型的数组，元素类型是任意的
    - 如果是 memory 型的数组，元素类型不能是 mapping
  - struct
  - mapping
    - 创建的时候，创建所有 key，所有 key 的值是 0
  - bytes/string - 变长字符数组。一个是 Hex 编码，一个是 UTF-8 编码

### 示例：水龙头合约

文件：`Faucet.sol`

```sol
pragma solidity ^0.4.17; // 指定Solidity语言版本

contract Faucet { // 合约名需要和文件名一致
  // 一个叫withdraw的公开的函数
  function withdraw(uint amount) public {
    require(amount <= 1000000000000000000); // 参数不能大于一个以太，即10^18 wei
    msg.sender.transfer(amount); // 通过一个inner transaction发送币
  }

  // 每个合约可以有一个没有名字的函数，称为回退函数(fallback)
  // 其他函数都没有被调用时，调用此函数
  // payable 表示可支付的，即可以接受别人的币
  // 函数里面没有任何操作，所以接受币的时候没有任何操作就接受
  function () public payable {}
}
```

### 示例：能存储数据的合约

```solidity
pragma solidity ^0.4.22;

contract SimpleStorage {
  uint data;
  // 也可以把变量设置为Public，可以从外部直接读取（getter）
  // public uint data;

  function setData(uint newData) public {
    data = newData;
  }

  // view表示此函数不会修改状态
  // 支持多返回值
  function getData() public view returns(uint) {
    return data;
  }

  // pure表示此函数是纯粹的计算函数，不会访问状态
  // 返回值可以在函数头命名
  function pureAdd(uint a, uint b) public pure returns(uint sum) {
    return a + b;
  }

  // 构造函数，可以在创建智能合约的时候给变量设置初始值
  constructor(uint initValue) public {
    data = initValue;
  }
}
```

### 示例：空气币

可以无限发币

```solidity
pragma solidity ^0.4.22;

contract Coin {
  address public minter; // 铸币者
  mapping (address => uint) public balances; // 所有账户的余额
  event Sent(address from, address to, uint amount); // 定义一个事件，以便被外部监听

  constructor() public {
    minter = msg.sender; // 创建此币的人为铸币者
  }

  function mint(address receiver, uint amount) public {
    require(msg.sender == minter); // 只有铸币者可以铸币
    balances[receiver] += amount; // 接收者获得此币
  }

  function send(address receiver, uint amount) public {
    require(amount <= balances[msg.sender]); // 发送者要拥有足够的币
    balances[msg.sender] -= amount;
    balances[receiver] += amount; // 需要注意uint是256位，可能有溢出的问题
    emit Sent(msg.sender, receiver, amount);
  }
}
```

### 官方示例：一种子货币

https://www.ethereum.org/token

总量固定

```solidity
pragma solidity ^0.4.20;

contract Token {
  mapping (address => uint256) public balance;

  constructor(uint256 initialSupply) public {
    balance[msg.sender] = initialSupply;
  }

  function transfer(address to, uint256 amount) public returns (bool success) {
    require(balance[msg.sender] >= amount);
    require(balance[to] + amount >= balance[to]); // 防溢出
    balance[msg.sender] -= amount;
    balance[to] += amount;
    return true; // 第三方平台可以根据返回值判断是否交易成功
  }
}
```

### 示例：简单的投票合约

```solidity
pragma solidity ^0.4.22;

contract Ballot {
  struct Voter {
    uint weight;
    bool voted;
    uint8 vote;
    address delegate;
  }

  struct Proposal {
    uint voteCount;
  }

  address chairperson;
  mapping (address => Voter) voters;
  Proposal[] proposals;

  constructor(uint8 numProposals) public {
    chairperson = msg.sender;
    voters[chairperson].weight = 1;
    proposals.length = numProposals;
  }

  function giveRightToVote(address to) public {
    require(msg.sender == chairperson);
    require(!voters[to].voted);
    voters[to].weight = 1;
  }

  function delegate(address to) public {
    Voter sender = voters[msg.sender];
    require(!sender.voted);
    while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
      to = voters[to].delegate;
    if (to == msg.sender) return; // delegate to self

    sender.voted = true;
    sender.delegate = to;
    Voter storage delegateTo = voters[to];
    if (delegateTo.voted)
      proposals[delegateTo.vote].voteCount += sender.weight;
    else
      delegateTo.weight += sender.weight;
  }

  function vote(uint8 toProposal) public {
    Voter storage sender = voters[msg.sender];
    if (sender.voted || toProposal >= proposals.length) return;
    sender.voted = true;
    sender.vote = toProposal;
  }

  function winningProposal() public constant returns (uint8 result) {
    uint256 winningVoteCount = 0;
    for (uint8 prop = 0; prop < proposals.length; prop++) {
      if (proposals[prop].voteCount > winningVoteCount) {
        winningVoteCount = proposals[prop].voteCount;
        result = prop;
      }
    }
  }
}
```

### 标准规范

有一些常见的需求已经被标准化，比如发币、NFT 等

- ERC20 - 代币合约

### 事件监听

```js
Coin.Sent().watch({}, '', (err, result) => {
  if (!err) {
    ...
  }
})
```

# 编译原理 目录

- [编译概述](1.md)
- [词法分析](2.md)
- [语法分析-自顶向下](3.md)
- [语法分析-自底向上](4.md)
- [语法制导翻译](5.md)
- [语义分析](6.md)
- [运行环境](7.md)
- [中间代码生成](8.md)
- [目标代码生成](9.md)
- [代码优化](10.md)


# 词法分析

## 预备知识

### 正则语言、正则文法、正则集和正则式

正则文法（3型文法）**包括两种**：
- 右线性文法(Right-linear Grammar)
  - 生成式左侧为一个非终结符，右侧为终结符串（可以为空）或终结符后接**一个**非终结符
- 左线性文法(Left-linear Grammar)
  - 生成式左侧为一个非终结符，右侧为终结符串（可以为空）或**一个**非终结符后接一个终结符串

>所以不要记成~~**正则文法等于右线性文法**~~，应该是**正则文法包含右线性文法**

正则语言、正则文法、正则集、正则式的关系：
- 正则语言可以用正则文法定义，也可以用正则式定义
- 每个正则文法都有一个正则式与之一一对应，反之亦然
- 正则集为正则文法或正则式定义的语言的集合（通常可以写成串的集合

### 状态转换图

起始状态有一个无源箭头，终止状态为两个圈

## 词法分析程序做什么

- 从源文件中分析出各类符号
- 词法检查，防止词法错误
- 创建符号表
- 跳过注释和空白

## 符号类型

以C语言为例
- 标识符
- 关键字
- 运算符
- 界符
  - 如小括号、大括号
  - 注意中括号应该是下标运算符
- 字面量
- 注释

## 输入

### 概述

输入串一般放在一个缓冲区中，即输入缓冲区。词法分析工作在这个缓冲区中进行。

输入部分有多种模型候选：
- 双指针单缓冲区
- 双指针配对缓冲区
- 保存子串

### 双指针单缓冲区

**不保存当前已分析的子串**，而是使用两个指针一个指向子串首（开始指针），一个指向字串尾（向前指针或搜索指针）。

如分析`while (1) for (;;) break;`语句，分析到`for`时，一个指针指向`f`，另一个指针向前搜索，搜索到空格之后判定当前子串为关键字`for`。

**要求**：**任何符号长度不能超过缓冲区长度**

但是这个限制仍然不够，比如以下问题：读到词串`for`之后读到了缓冲区尾，有如下两种情况：
- `for`后面紧挨着其他字母或数字形成`forXX`，为标识符
- `for`后面是空白符或括号`(`，所以`for`是关键字

也就是**符号被缓冲区边界切断**的问题

此时需要刷新缓冲区，加载下一批字符来向前读取。那么开始指针就会失效。

解决方案：使用双指针+配对缓冲区或者保存子串

### 双指针+配对缓冲区技术

解决的问题：为了判断某个单词的词性，需要**超前扫描和回退**

设置两个指针：
- 开始指针 - 记录词首
- 向前指针（搜索指针） - 搜索词尾

**配对缓冲区**策略：把一个缓冲区分成大小相同的两半，一次加载一半，防止回退时再次加载上一个缓冲区。

**要求**：**任何符号的长度都不能超过配对缓冲区整体的长度**

## 输出记号

输出通常是二元组token：`<class, value>`

关键字、运算符、界符的记号设置方式可以是**一符一种**（每个符号一个class，没有value，直接使用class区分），也可以是**一类一种**（把一类符号设置为一个class，使用value区分）。如赋值运算符类：

| 赋值运算符 | 按照一符一种设置记号 | 按照一类一种设置记号 |
| --- | --- | --- |
| `=` | `<op_assign, ->` | `<op_assign, =>` |
| `+=` | `<op_add_assign, ->` | `<op_assign, +=>` |
| `-=` | `<op_minus_assign, ->` | `<op_assign, -=>` |
| `*=` | `<op_multiple_assign, ->` | `<op_assign, *=>` |
| `/=` | `<op_divide_assign, ->` | `<op_assign, /=>` |

两种方案都可以用，视情况而定。

觉得有用？欢迎[打赏](../../../donate.md)

:)

[返回主页](../../../index.md)
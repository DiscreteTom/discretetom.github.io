# 算法设计与分析 目录

- [第一章 概述](Chapter1.md)
- [第二章 递归分治](Chapter2.md)
- [第三章 动态规划](Chapter3.md)
- [第四章 贪心算法](Chapter4.md)
- [第五章 回溯法](Chapter5.md)
- [第六章 分支限界法](Chapter6.md)
- [总结](Summary.md)

# 第二章 递归与分治

## 分治法概念

>不是所有递归函数都可以找到非递归的定义

分治法适用条件：

- 问题规模缩小到一定程度可以很容易解决
- 问题可以分解为若干个规模较小的相同问题，即**最右子结构**性质
- 子问题的（简单）合并可以得到原问题的解
	- 如果不满足，考虑贪心或动态规划
- 大问题分解为子问题后各个子问题可以独立（并行、同时）求解，相互无依赖关系，不包含公共子问题
	- 如果存在公共子问题，适用动态规划

>平衡子问题：如果可以，把问题一分为二总是比其他划分方法更好。

>正例：二分搜索、合并排序

>反例：汉诺塔问题

## 算法复杂性分析

如果把规模为n的问题分解成k个规模为n/m的子问题，合并结果的时间为f(n)，最小子问题为n0，则时间复杂度为

```
T(n)=O(1)            n=n0
T(n)=kT(n/m)+f(n)    n>n0
```

通过迭代法求得方程的解

```
T(n)=n^(logm(k))+Σ(j=0 -> logm(n-1))k^jf(n/m^j)
```

### m & k的影响

- 如果```m < k```，也就是说```k * (n / m) > n```，分解后问题规模大于原问题规模
	- T(n)复杂性较大，如矩阵乘法问题
- 如果```m = k```，分解后问题规模等于原问题规模
	- 合并排序
- 如果```m > k```，分解后问题规模小于原问题规模（减治）
	- 二分查找

## 二分查找

已知**有序**数组```a[n]```，从```a[l]```到```a[r]```中找元素```aim```

流程（以升序数组为例）：

- 比较l和r
	- 如果l==r且a[l]==aim那么aim的下标就是l。如果a[l]!=aim那么数组中没有aim
	- 如果l!=r那么令mid=(l+r)/2，比较a[mid]和aim
		- 如果a[mid]>aim，令r=mid-1
		- 如果a[mid]<aim，令l=mid+1

复杂度O(logn)

## 大整数乘法

使用加法换乘法的思想

两个n位二进制大整数分别为x和y，把x和y分别均分成两部分，即x的左边n/2位为a，右边n/2为b，记为x=ab。同理令y=cd。则x乘y可以计算为

```
x = a * 2^(n/2) + b
y = c * 2^(n/2) + d
x * y = a*c*2^n + (b*c+a*d)*2^(n/2) + b*d
```

上式包含四次n/2规模的乘法，计算发现```T(n)=4T(n/2)+O(n)```，```T(n)=O(n^2)```，没有改进

如果要改进，必须减少乘法次数。改进方案如下

```
x * y = a*c*2^n + ((a-b)(d-c) + a*c + b*d)*2^(n/2) + b*d
```

式中```a*c```和```b*d```均出现了两次，只需要计算一次保存结果就行了。所以一共出现了3此规模n/2的乘法，所以```T(n)=3T(n/2)+O(n)```，复杂度```T(n)=O(n^1.59)```

## 合并排序

最小子问题规模为2，只要简单比大小就可以把两个元素排序

思想是每次把问题拆分成两个（相等的）子问题，把两个子序列排序之后合并

复杂度```T(n)=2T(n/2)+O(n)```具体计算得到```T(n)=O(nlogn)```

需要辅助空间O(n)

特点

- 分解简单
- 合并复杂

## 快速排序

以升序为例

按照基准元素把序列划分为三个子序列```a[l:q-1], a[q], a[q+1, r]```，其中```a[l:q-1]```中所有元素小于```a[q]```，```a[q+1:r]```中所有元素大于```a[q]```。

策略：指针i从左向右搜索，指针j从右向左搜索，当```a[i]>a[q]&&a[j]<a[q]```的时候交换```a[i]```与```a[j]```。

个人感觉这个策略没有学习数据结构时的那个交替的策略好

改进策略

- 判断子序列是否已经有序
- 随机选择基准元素

时间复杂性

- 最坏 O(n^2)
- 平均 O(nlogn)

辅助空间O(n)或O(logn)

## 线性时间选择

从快速排序的思想延伸而来。用于寻找序列中第k大的元素而不需要把整个序列完全排序。

思路：和快排类似，选择基准元素并把序列分为3份。目标元素在其中一份中，以此做到减治

基准元素的选择：把序列元素以5个一组分组，用任意排序方法（如冒泡）把所有组的5个元素排序，取出所有组的中位数，并求这些中位数的中位数。

优化：当序列长度小于指定值（理论上应取20）时直接简单排序求第k个元素

复杂度```T(n)=O(n)```

## 平面最近点对（略）

### 面向一维的算法

寻找坐标中位数m作为分割点把所有点分成两部分

## 矩阵乘法（略）

## 棋盘覆盖（略）
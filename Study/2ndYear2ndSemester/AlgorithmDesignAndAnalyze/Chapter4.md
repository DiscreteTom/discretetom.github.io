# 算法设计与分析 目录

- [第一章 概述](Chapter1.md)
- [第二章 递归分治](Chapter2.md)
- [第三章 动态规划](Chapter3.md)
- [第四章 贪心算法](Chapter4.md)
- [第五章 回溯法](Chapter5.md)
- [第六章 分支限界法](Chapter6.md)
- [总结](Summary.md)

# 第四章 贪心法

## 基本要素

得到最优解的条件：

- 最优子结构
	- 原问题最优解包括了子问题最优解
- 贪心选择性质
	- 整体最优解可以通过一系列局部最优解的选择（即贪心选择）来得到

贪心思想：自顶向下，每次选择的时候都选择对当前局势下最优的方案而不考虑整体。即局部最优

## 活动安排问题

贪心选择策略：每次都选择结束时间最早的活动，为剩余活动提供尽可能多的时间。

如果输入已经成升序，时间复杂性O(n)。如果没有排序则需要手动排序，时间复杂性O(nlogn)

### 证明

使用数学归纳法证明贪心法能够求得活动安排问题的整体最优解

思路：

1. 假设存在一个最优解
2. 证明存在一个以贪心选择开始的最优解
3. 证明贪心选择后的子问题也是通过贪心选择获得的最优解

过程：

设E1-En为n个活动。而且已经按照结束时间升序排列。所以E1拥有最早的结束时间。需要证明最优解中总是包含了E1。
假设最优解A的第一个活动是Ek，如果k!=1，假设另一个解B内不包含Ek而包含E1其他和A一样，因为E1最早结束，所以B内的活动都是相容的。因为B内的活动与A内的活动数量相同，而且A是最优的，所以B也是最优的。

也就是说，贪心不一定能在此问题求出所有最优解（事实上只能求一个），但是求出来的必定是最优解

## 背包问题

注意不是0-1背包问题。此背包问题中的物品可以被无限分割，所以贪心选择的时候选择单位质量下价值最大者放入。直到背包装满。

0-1背包问题不能通过贪心法获得最优解

因为需要排序，时间复杂度O(nlogn)

## 装载问题

0-1背包的特殊形式，相当于每个物品的价值都是1。

贪心策略：每次都装载最轻的物品，尽可能给剩余物品提供更多容量。

时间复杂度O(nlogn)

## 哈夫曼编码

构造编码树生成最优前缀码

计算时间O(nlogn)

### 证明-贪心选择性质

需要证明：假设x和y是有最小频率f(x)和f(y)的2个字符，则最优前缀码中x和y有相同的码长，且只有最有一位编码不同。如果能够证明这个结论，就说明按照每次优先选择最小频率的两个字符的个构造算法是正确的，是能够造出全局最优的。

思路：如果x和y不在二叉树的最深叶子上，那么交换x和最深的叶子可以减少（或不会增加）平均码长。所有x和y在二叉树最深叶子上的编码方式一定是最优解

### 证明-最优子结构性质

需要证明：给定字符集和其最优前缀码，可以从中得到子问题的最优前缀码（树）

反证：如果存在子树，生成的码不是最优前缀码

## 单源最短路径

Dijkstra算法

贪心策略：每次选择“不在可达点集内的”距离最近的点加入可达点集。每次加入新顶点后要刷新可达点集外的点的距离

## 最小生成树

### Prim算法

贪心策略：已知树内点集S，每次向外延伸一个点，这个点是树内点集到树外点集距离最小的一个点。

时间复杂度O(n^2)

### Kruskal算法

贪心策略：每次判断最短的边。如果这条边的两个顶点不在任何集合内，那么这两个顶点形成一个集合。如果其中一个顶点已经在一个集合中，那么把另一个顶点也并入这个集合。如果两个顶点在不同集合则合并两个集合。如果两个顶点在同一集合则舍弃这个边。最后的效果是我们通过寻找最小的边构造出了联通的图。

时间复杂度O(eloge)，e为边的数量
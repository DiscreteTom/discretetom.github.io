---
layout: collection
author: DiscreteTom
catalog: true
title: '消隐技术'
collection: ComputerGraphics
---

## 概述

>消隐 - 找出并消除物体中不可见的部分

经过消隐得到的图形称为消隐图

消隐的对象是三维物体

根据消隐对象的不同，有两类消隐算法：
- 消除不可见的线段 - 线消隐
- 消除不可见的面 - 面消隐

消隐不仅与对象有关，还与投影有关

通常投影平面为XOY，投影方向为负Z

根据消隐空间的不同，也可以分为两类：
- 物体空间消隐 - 计算物体所在空间的遮挡关系
- 图像空间消隐 - 计算物体在屏幕上是否可见

消隐算法种类繁多，但是必然涉及**排序**和**相关性**两个基本原则：
- 排序 - 为了确定对象之间的遮挡关系，大多数算法都会在Z方向排序，确定对象相对于观察点的距离，然后在X和Y方向进一步排序，确定遮挡关系
- 相关性 - 指所考察的物体或视图区内的图像局部保持不变的一种性质。相关性利用得越充分、巧妙，消隐算法效率越高

## 区域子分算法

### 概述

![](../img/8-1.png)

针对光栅扫描式图像显示器

分治算法

每次把矩形窗口等分为4个相等矩形（称为窗口），每一次子分都计算要显示的多边形和窗口的关系：
- 多边形包围了窗口（下图1
- 多边形和窗口相交（下图2
- 窗口包围多边形（下图3
- 二者分离（下图4

![](../img/8-2.png)

确定窗口和每个多边形的关系后：
- 如果所有多边形都和窗口分离，窗口填充背景色
- 只有一个多边形和窗口相交或在窗口内，则窗口填充背景色，然后使用扫描算法画多边形
- 距离观察者最近的多边形包围了窗口，则窗口填充目标颜色
- 如果以上都不是，则进一步四分窗口

### 改进效率 - 边界盒方法

此方法可以用来判断两个线段或者多边形是否相交

多边形的边界盒是包含这个多边形的平行于坐标轴的最小矩形，由四个参数决定:$x_{max}, x_{min}, y_{max}, y_{min}$

如果边界盒不想交，则二者不相交

### 遮挡判断

把窗口的顶点坐标代入目标多边形的平面方程得到Z值

如果有多个多边形，多边形A的最小Z不小于多边形B的最大Z，那么多边形B被遮挡

否则，老老实实根据X和Y计算哪个面的Z最大

## 深度缓存算法

### 概述

Z-Buffer

是一种最简单的图像空间面消隐算法，适用于多边形和其他曲面

需要深度缓存数组ZB，大小与屏幕像素个数相同，也与显示器的帧缓存FB单元个数相同。一一对应

对于显示器的每一个点(x, y)，向Z轴发射射线，取最大Z值存在ZB，对应的颜色存在显示器的FB

![](../img/8-3.png)

### 算法步骤

假设有N个多边形，屏幕像素个数为$m \times n$

```python
# 初始化ZB为Z的极小值
# 初始化FB为背景色
for i in range(1, n):
	for j in range(1, m):
		for k in range(1, N): # 遍历多边形
			if point(i, j) in polygon[k].projection:
				# 射线与多边形有交点
				if polygon[k](i, j) > ZB(i, j):
					# 如果Z大于当前ZB的Z
					ZB(i, j) = polygon[k](i, j)
					FB(i, j) = polygon[k](i, j).color
```

## 扫描线算法（略

ZB算法的优点是简单可靠，不需要对显示对象的面进行排序。缺点是需要很大的ZB，对于每一个像素都要计算Z，工作量大

面向多边形场景的扫描线算法解决上述问题

类似于多边形扫描线填充算法，首先以y为步增方向，根据多边形在XOY轴投影的图形，计算y+1时x的增量，从而根据递推公式计算出多边形在XOY轴投影的边界的各个点。然后对于XOY投影的边界的各个点步增时Z轴的增量，即可得到深度Z